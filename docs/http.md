
# HTTP

> 内容来源于《图解http》

***

### Part1—— Web及网络基础

3 项 `WWW（简称Web）` 构建技术，分别是：
* 把 SGML（Standard Generalized Markup Language，标准通用标记语言）作为页面的文本标记语言的 HTML（HyperText Markup Language，超文本标记语言）；
* 作为文档传递协议的 HTTP ；
* 指定文档所在地址的 URL（Uniform Resource Locator，统一资源定位符）。 

不同的硬件、操作系统之间的通信，都需要一种规则。这种规则称为**协议（protocol）**。`TCP/IP` 是互联网相关的各类协议族的总称。

#### TCP/IP的分层

四层：应用层、传输层、网络层、和数据链路层。

> 分层的一些好处：1.分层即把整体部分化，当有某个地方出现问题时不必改一个大整体，可以只改出现问题的一小部分。2.简化设计。

1. **应用层**

应用层决定了向用户提供应用服务时通信的活动。

TCP/IP 协议族内预存了各类通用的应用服务。比如，FTP（File Transfer Protocol，文件传输协议）和 DNS（Domain Name System，域名系统）服务就是其中两类。
 
**HTTP 协议处于该层**。
 
2. **传输层** 
 
传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。 

在传输层有两个性质不同的协议：**TCP(Transmission Control Protocol，传输控制协议)** 和 UDP（User Data Protocol，用户数据报协议）。 
 
3. **网络层（又名网络互连层）**

网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径 （所谓的传输路线）到达对方计算机，并把数据包传送给对方。 

与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一 条传输路线。 

4. **链路层（又名数据链路层，网络接口层）**

用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范 畴均在链路层的作用范围之内。 


<!-- 这里缺一个TCP/IP通信传输流（封装）的流程图 -->
发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在 层与层传输数据时，每经过一层时会把对应的首部消去。 这种把数据信息包装起来的做法称为封装（encapsulate）。

#### 与http关系密切的协议：IP、TCP、DNS

##### 1.负责传输的 IP

**IP（Internet Protocol）** 网际协议,位于网络层，也即TCP/IP 协议族中的 IP。作用是把各种数据包传送给对方。

> tips：此``IP``是一种协议的名称，需要与``IP地址``区别开。

IP传送条件：IP 地址（指明了节点被分配到的地址），MAC 地址（指网卡所属的固定地址）。



##### 2.负责保障的 TCP

**TCP** 位于传输层，提供**可靠**的**字节流服务**。即TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到 对方。 

TCP的 **三次握手**

用 TCP 协议把数据包送出去后，TCP 不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。 握手过程中使用了 TCP 的标志（ﬂag） —— SYN（synchronize） 和 ACK（acknowledgement）。 

发送端首先发送一个带 SYN 标志的数据包给对方。``（一次）`` 接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。``(两次)`` 最后，发送端再回传一个带 ACK 标志的数据包，``（三次）`` 代表“握手”结束。


##### 3.负责域名解析的 DNS

DNS（Domain Name System），提供域名到 IP 地址之间的解析服务。位于应用层。

DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。

#### URI和URL

URL（Uniform Resource Locator，统一资源**定位符**）

URI（Uniform Resource Identiﬁer，统一资源**标识符**）

Uniform 规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式。另 外，加入新增的协议方案（如 http: 或 ftp:）也更容易。 

Resource 资源的定义是“可标识的任何东西”。除了文档文件、图像或服务（例如当天的天气预报）等能够区别于其 他类型的，全都可作为资源。另外，资源不仅可以是单一的，也可以是多数的集合体。 

Identiﬁer 表示可标识的对象。也称为标识符。综上所述，URI 就是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。 

URL 是 URI 的子集。 


***

### Part2—— http协议

#### 一 用于客户端和服务器之间的通信。 

#### 二 通过请求和响应的交换达成通信（报文）。

#### 三 不保存状态的协议。

#### 四 请求 ``URI定位的`` 资源。

#### 五 告知服务器意图的 **HTTP 方法**。

**HTTP方法：**
1. `GET`：获取资源 
GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。


2. `POST`：传输实体主体
POST 方法用来传输实体的主体。与GET的差别在于POST主要目的不是**获取**响应的主体内容。


3. `PUT`：传输文件 
PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后 保存到请求 URI 指定的位置。 


4. `HEAD`：获得报文首部
HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时 间等。


5. `DELETE`：删除文件 
DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按请求 URI 删除指定的资源。


6. `OPTIONS`：询问支持的方法 
OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。


7. `TRACE`：追踪路径
TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。 


8. `CONNECT`：要求用隧道协议连接代理 
CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议 把通信内容加 密后经网络隧道传输。 

#### 六 持久连接节省通信量（持久连接、管线化）

#### 七 使用 Cookie 的状态管理

Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。

``` 
1. 请求报文（没有 Cookie 信息的状态）-> 
2. 响应报文（服务器端生成 Cookie 信息）-> 
3. 请求报文（自动发送保存着的 Cookie 信息）
```

***

### Part3—— http报文内的http信息

#### http报文

用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的 HTTP 报文叫做请求报文，响应端 （服务器端）的叫做响应报文。HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。 HTTP 报文大致可分为报文首部和报文主体两块。通常，并不一定要有报文主体。

报文（message） 
是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence，其中 octet 为 8 个比 特）组成，通过 HTTP 通信传输。 

实体（entity） 
作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。 

#### 其他

* 请求报文及响应报文的结构

* 编码提升传输速率 

* 发送多种数据的多部分对象集合

* 获取部分内容的范围请求

* 内容协商返回最合适的内容 

***
### Part4——返回结果的HTTP状态码

HTTP 状态码负责表示客户端 HTTP 请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。比如404。

状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。

状态码类别：
|  状态码  | 类别 | 原因短语 |
|:--:| :--: | :--:    |
|1XX |Informational（信息性状态码） |接收的请求正在处理|
|2XX |Success（成功状态码） |请求正常处理完毕 |
|3XX |Redirection（重定向状态码） |需要进行附加操作以完成请求 |
|4XX |Client Error（客户端错误状态码） |服务器无法处理请求 |
|5XX |Server Error（服务器错误状态码） |服务器处理请求出错 |


#### 1) 2XX 成功 

2XX 的响应结果表明请求被正常处理了。

* **200 OK**：表示从客户端发来的请求在服务器端被正常处理了。 

* **204 No Content**：请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。

* **206 Partial Content**：表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。

#### 2) 3XX 重定向 

3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。 

* **301 Moved Permanently**：永久性重定向，表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。

* **302 Found**：临时性重定向，表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。 

* **303 See Other**：表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。 

* **304 Not Modiﬁed**：表示客户端发送附带条件的请求 2 时，服务器端允许请求访问资源，但未满足条件的情况。

* **307 Temporary Redirect**：临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。

#### 3) 4XX 客户端错误 

4XX 的响应结果表明客户端是发生错误的原因所在。 

* **400 Bad Request**：表示请求报文中存在语法错误。另外，浏览器会像 200 OK 一样对待该状态码。 

* **401 Unauthorized**：表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示用户认证失败。 

* **403 Forbidden**：表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。 

* **404 Not Found**：表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。

#### 4) 5XX 服务器错误 

5XX 的响应结果表明服务器本身发生错误。 

* **500 Internal Server Error**：表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。

* **503 Service Unavailable**：表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

***

### Part5—— 与 HTTP 协作的 Web 服务器 

一台 Web 服务器可搭建多个独立域名的 Web 网站，也可作为通信路径上的中转服务器提升传输效率。

#### 用单台虚拟主机实现多个域名 

HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点

在互联网上，域名通过 DNS 服务映射到 IP 地址（域名解析）之后访问目标网站。可见，当请求发送到 服务器时，已经是以 IP 地址形式访问了。 所以，如果一台服务器内托管了 www.tricorder.jp 和 www.hackr.jp 这两个域名，当收到请求时就需要 弄清楚究竟要访问哪个域名。

在相同的 IP 地址下，由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站，因此在发送 HTTP 请求时，必须在 Host 首部内完整指定主机名或域名的 URI。？？？

#### 通信数据转发程序 ：代理、网关、隧道

##### 代理 

代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“**中间人**”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。代理不改变请求 URI，会直接发送给前方持有资源的目标服务器。 

> 持有资源实体的服务器被称为源服务器

代理有多种使用方法，按两种基准分类。一种是是否使用缓存，另一种是是否会修改报文。

1. **缓存代理**
代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。 

2. **透明代理**
转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（Transparent Proxy）。反之，对报文内容进行加工的代理被称为非透明代理。 


##### 网关 

网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。 

利用网关可以由 HTTP 请求转化为其他协议通信 
利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。

##### 隧道 

隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。 
目的是确保客户端能与服务器进行安全的通信。 
隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL 等加密手段进行通信。


#### 缓存

缓存是指在代理服务器或客户端本地磁盘内保存的资源副本。

* 缓存代理服务器能向原服务器确认缓存有效性进而判别缓存内容是否过期。
* 在客户端（浏览器）缓存称为临时网络文件。过期后也会向代理服务器确认有效性。

### HTTP首部

HTTP 协议的请求和响应报文中必定包含 HTTP 首部。首部内容为客户端和服务器分别处理请求和响应提 供所需要的信息。

<!-- 太多太重点了 -->

### 确保安全的https



HTTP 主要有这些不足，例举如下。
 
1. 通信使用明文（不加密），内容可能会被窃听

HTTP 协议中没有加密机制

加密

* 通信加密
SSL（Secure Socket Layer，安全套接层）或 TLS（Transport Layer Security，安全层传输协议）的组合使用，加密 HTTP 的通信内容。与 SSL 组合使用的 HTTP 被称为 **HTTPS（HTTP Secure，超文本传输安全协议）**或 HTTP over SSL。

* 内容加密
对 HTTP 协议传输的内容本身加密。即把 HTTP 报文里所含的内容进行加密处理

2. 不验证通信方的身份，因此有可能遭遇伪装 

* 由于不存在确认通信方的处理步骤，任何人都可发起请求，服务器也都会有回应（除非其端口限制）。

> 1. 无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有> 可能是已伪装的 Web 服务器。 
> 2. 无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已> 伪> 装的客户端。 
> 3. 无法确定正在通信的对方是否具备访问权限。因为某些 Web 服务器
> 上保存着重要的信息，只想发给特定用户通信的权限。
> 4. 无法判定请求是来自何方、出自谁手。 
> 5. 即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击 （Denial of > Service，拒绝服务攻击）。 

* 查明对手的证书 

SSL 不仅提供加密处理，而且还使用了一种被称为证书的手段，可用于确定方。

客户端持有证书即可完成个人身份的确认，也可用于对 Web 网站的认证环节。 

3. 无法证明报文的完整性，所以有可能已遭篡改

HTTP 协议无法证明通信的报文完整性，没有任何办法确认，发出的请求 / 响应和接收到的请求 / 响应是前后相同的。

> 即在传输过程中被遭攻击者拦截并篡改内容的攻击称为**中间人攻击**（Manin-the-Middle attack，MITM）> 但两端通信看上去还是正常的。

#### HTTP+加密+认证+完整性保护=HTTPS（HTTP Secure）

HTTPS并非是应用层的一种新协议。是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替。

HTTP:
|应用（HTTP）|
|:--:|
|TCP|
|IP|

HTTPS:
|应用（HTTP）|
|:--:|
|SSL|
|TCP|
|IP|

> SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是当今世界上应用最为广泛的网络安全技术。 

公开密钥加密技术

SSL 采用一种叫做**公开密钥加密（Public-key cryptography）**的加密处理方式。 
加密和解密都会用到密钥。任何人只要持有密钥就能解密。（共享密钥加密的弊端）

公开密钥加密使用一对**非对称**的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。 使用公开密钥加密方式，发送密文的一方使用对方的**公开密钥进行加密处理**，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。 

HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。

若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其**处理速度要慢**。 

所以应充分利用两者各自的优势，将多种方法组合起来用于通信。**在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。**（即先给安全的给密钥对方，后面的通信就可以安全使用共享加密）

另一个层次：公开密钥可能是假的，亦会造成信息泄露。
解决方法：由数字证书机构颁发**公开密钥证书**（简称数字证书或证书）。

> 数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。

证书的一个作用是用来证明作为通信一方的服务器是否规范，另外一个作用是可确认对方服务器背后运营的企业是否真实存在。拥有该特性的证书就是 EV SSL 证书（Extended Validation SSL Certiﬁcate）。

### 确认访问用户身份的认证
访问用户身份认证就是要确定访问的人是不是网页指定的允许的人。

HTTP/1.1使用的认证方式：
1. BASIC认证(基本认证)
2. DIGEST认证(摘要认证)
3. SSL客户端认证
4. FormBase认证(基于表单认证)


1. BASIC认证

可以认为是简单的填写用户名和密码认证。
具体实现：

步骤 1： 当请求的资源需要 BASIC 认证时，服务器会随状态码 401 Authorization Required，返回带 WWW-Authenticate 首部字段的响应。该字段内包含认证的方式（BASIC） 及 Request-URI 安全域字 符串（realm）。
步骤 2： 接收到状态码 401 的客户端为了通过 BASIC 认证，需要将用户 ID 及密码发送给服务器。发 送的字符串内容是由用户 ID 和密码构成，两者中间以冒号（:）连接后，再经过 Base64 编码处理。 假设用户 ID 为 guest，密码是 guest，连接起来就会形成 guest:guest 这样的字符串。然后经过 Base64 编码，最后的结果即是 Z3Vlc3Q6Z3Vlc3Q=。把这串字符串写入首部字段 Authorization 后，发送请求。 当用户代理为浏览器时，用户仅需输入用户 ID 和密码即可，之后，浏览器会自动完成到 Base64 编码的 转换工作。
步骤 3： 接收到包含首部字段 Authorization 请求的服务器，会对认证信息的正确性进行验证。如验证 通过，则返回一条包含 Request-URI 资源的响应。 
BASIC 认证虽然采用 Base64 编码方式，但这不是加密处理。不需要任何附加信息即可对其解码。换言 之，由于明文解码后就是用户 ID 和密码，在 HTTP 等非加密通信的线路上进行 BASIC 认证的过程中， 如果被人窃听，被盗的可能性极高。 
另外，除此之外想再进行一次 BASIC 认证时，一般的浏览器却无法实现认证注销操作，这也是问题之 一。 
BASIC 认证使用上不够便捷灵活，且达不到多数 Web 网站期望的安全性等级，因此它并不常用。


2. DIDEST认证












