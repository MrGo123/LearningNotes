# CPP

### 简介
C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。C++ 是区分大小写的编程语言。

### 面向对象程序设计
C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性：

* 封装
* 数据隐藏
* 继承
* 多态

### 数据类型

#### 常见类型

|类型       |       位      |            范围|
|:--:       |:--:           |   :--:           |
|char	    |1 个字节       |	-128 到 127 或者 0 到 255|
|unsigned char|	1 个字节    |	0 到 255|
|signed char|	1 个字节	|-128 到 127|
|int	    |4 个字节       |	-2147483648 到 2147483647|
|unsigned int|	4 个字节    |	0 到 4294967295|
|igned int  |	4 个字节    |	-2147483648 到 2147483647|
|short int  |	2 个字节    |	-32768 到 32767|
|unsigned short int|	2 个字节	|0 到 65,535|
|signed short int|	2 个字节|	-32768 到 32767|
|long int   |	8 个字节        |	-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807|
|signed long int|	8 个字节|	-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807|
|unsigned long int|	8 个字节|   0 to 18,446,744,073,709,551,615|
|float	    |4 个字节       |	+/- 3.4e +/- 38 (~7 个数字)|
|double	    |8 个字节       |	+/- 1.7e +/- 308 (~15 个数字)|
|long double|	16 个字节   |	+/- 1.7e +/- 308 (~15 个数字)|
|wchar_t	|2 或 4 个字节  |	1 个宽字符|

#### 枚举类型

枚举类型声明一个可选的类型名称和一组标识符，用来作为该类型的值。其带有零个或多个标识符可以被用来作为该类型的值。每个枚举数是一个枚举类型的常数。

tips:

* 变量声明：`extern`可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义，即**声明**。
* 常量声明：使用`#define`预处理器，或`const`声明常量。
* 变量作用域：**局部变量**在函数中可以覆盖**全局变量**；

#### 转义字符

|转义序列	|含义|
|:--:       |:--:           |
|\\\	|\ 字符|
|\\'	|' 字符|
|\\"	|" 字符|
|\\?	|? 字符|
|\a	|警报铃声|
|\b	|退格键|
|\f	|换页符|
|\n	|换行符|
|\r	|回车|
|\t	|水平制表符|
|\v	|垂直制表符|
|\ooo	|一到三位的八进制数|
|\xhh . . .|	一个或多个数字的十六进制数|

#### 存储类

存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前（eg：```auto int age;```）。下面列出 C++ 程序中可用的存储类：

* **auto**：所有局部变量默认的存储类。
* **register**：定义存储在寄存器中而不是 RAM 中的局部变量
* **static**:指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。
* **extern**:用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。
* **mutable**

### 运算符

#### 位运算符

假设变量 A 的值为 60，变量 B 的值为 13，则：

|运算符	|描述	|实例|
|:--:|:--:|:--:|
|&|	如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。|	(A & B) 将得到 12，即为 0000 1100|
|\||	如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。|	(A \| B) 将得到 61，即为 0011 1101|
|^|	如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。|	(A ^ B) 将得到 49，即为 0011 0001|
|~	|二进制补码运算符是一元运算符，具有"翻转"位效果。|	(~A ) 将得到 -61，即为 1100 0011，2 的补码形式，带符号的二进制数。|
|<<|	二进制左移运算符。左操作数的值向左移动右操作数指定的位数。|	A << 2 将得到 240，即为 1111 0000|
|>>|	二进制右移运算符。左操作数的值向右移动右操作数指定的位数。|	A >> 2 将得到 15，即为 0000 1111|

### 函数

使用缺省参数函数
1. 不可以靠左边缺省；
2. 函数原型说明时可以不加变量名；
3. 只能在前面定义一次缺省函数。

例如：



条件编译？？

#### 参数默认值

当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。

这是通过在函数定义中使用赋值运算符来为参数赋值的。调用函数时，如果未传递参数的值，则会使用默认值，如果指定了值，则会忽略默认值，使用传递的值。请看下面的实例：

```c++
#include <iostream>
using namespace std;
 
int sum(int a, int b=20)
{
  int result;

  result = a + b;
  
  return (result);
}

int main ()
{
   // 局部变量声明
   int a = 100;
   int b = 200;
   int result;
 
   // 调用函数来添加值
   result = sum(a, b);
    cout << "Total value is :" << result << endl;     // 再次调用函数
    result = sum(a); 
    cout << "Total value is :" << result << endl;
    return 0;
} 
```

输出
```c++
Total value is :300
Total value is :120
```

### C++中的数学

#### 数学运算

在 C++ 中，除了可以创建各种函数，还包含了各种有用的函数供您使用。这些函数写在标准 C 和 C++ 库中，叫做内置函数。

使用内置函数需引用数学头文件 `<cmath>`。


|序号   |	函数 |  描述    |
|:--:   | :--:  |   :--:   |
|1      |	double cos(double)  |  该函数返回弧度角（double 型）的余弦。|
|2	    |double sin(double)     |   该函数返回弧度角（double 型）的正弦。|
|3      |	double tan(double) |    该函数返回弧度角（double 型）的正切。|
|4      |	double log(double) |    该函数返回参数的自然对数。|
|5      |	double pow(double, double) |    假设第一个参数为 x，第二个参数为 y，则该函|数返回 x 的 y 次方。|
|6      |	double hypot(double, double) |  该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。|
|7      |	double sqrt(double) |   该函数返回参数的平方根。|
|8      |	int abs(int) |  该函数返回整数的绝对值。|
|9	    |double fabs(double) |  函数返回任意一个十进制数的绝对值。|
|10	    |double floor(double) | 该函数返回一个小于或等于传入参数的最大整数。|


#### 随机数

关于随机数生成器，有两个相关的函数。一个是 rand()，该函数只返回一个伪随机数。生成随机数之前必须先调用 srand() 函数。

```C++
#include <iostream>
#include <ctime>
#include <cstdlib>

using namespace std;
 
int main ()
{
   int i,j;
 
   // 设置种子
   srand( (unsigned)time( NULL ) );

   /* 生成 10 个随机数 */
   for( i = 0; i < 10; i++ )
   {
      // 生成实际的随机数
      j= rand();
      cout <<"随机数： " << j << endl;
   }

   return 0;
} 
```

### C++字符串

#### 使用字符串函数操作

|序号|	函数 | 目的|
|:--:|:--:|:--:|
|1|	strcpy(s1, s2) |复制字符串 s2 到字符串 s1。|
|2	|strcat(s1, s2) |连接字符串 s2 到字符串 s1 的末尾。|
|3|	strlen(s1) |返回字符串 s1 的长度。|
|4|	strcmp(s1, s2) |如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。|
|5|	strchr(s1, ch) |返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。|
|6	|strstr(s1, s2) |返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。|

#### String类

`string 类` 类型，支持上述所有的操作，另外还增加了其他更多的功能。

```c++
#include <iostream>
#include <string>

using namespace std;

int main ()
{
   string str1 = "Hello";
   string str2 = "World";
   string str3;
   int  len ;

   // 复制 str1 到 str3
   str3 = str1;
   cout << "str3 : " << str3 << endl;

   // 连接 str1 和 str2
   str3 = str1 + str2;
   cout << "str1 + str2 : " << str3 << endl;

   // 连接后，str3 的总长度
   len = str3.size();
   cout << "str3.size() :  " << len << endl;

   return 0;
} 
```

### C++引用

引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。使用 `&` 来引用。例如：

```c++
int i=1;
int& j=i;   // 即j的值就是i的值。
```

引用的实质是指针，旨在大部分情况下代替指针，

功能性：可以满足指针的多数需要使用指针的场合，

安全性：可以避开由于指针操作不当带来的内存错误

操作性：简单易用，又不失强大


### C++基本的输入输出

I/O库头文件

|头文件|函数&描述|
|:--:|--|
|\<iostream\>	|该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。|
|\<iomanip\>	|该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。|
|\<fstream\>	|该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。|

|\<iostream\>常见流|一般搭配|
|--|--|
|标准输出流（cout）|流插入运算符 << |
|标准输入流（cin）|流提取运算符 >> |
|标准错误流（cerr）|流插入运算符 <<|
|标准日志流（clog）|流插入运算符 <<|


### 面向对象

类的格式定义

```c++
class 类名
{
   int a;   //默认为private私有的。
    private:     
        成员数据;// int age; 
        成员函数;// int getAge(){}
                 //私有部分外部使用时需要通过public公有函数来访问。
    public:
        成员数据;//成员数据与成员函数定义不分先后；
        成员函数;
    protected:    //派生类中可以访问
        成员数据;
        成员函数;
};
```
类可以单独使用、可以嵌套在函数内部、另一个类的内部。

范围解析运算符：`::`

#### 拷贝构造函数？？
常见样式：
```C++
classname (const classname &obj) {
   // 构造函数的主体
}
```

#### 友元函数

类的友元函数是定义在类外部，但**有权访问类的所有私有（private）成员和保护（protected）成员**。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。

友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。

如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 **friend**.

> 相当于给一个函数权限，允许它访问这个类的所有成员。

声明一个类的所有成员函数为累的友元时，需要再类的定义前使用关键字**friend**
```c++
friend class Demo;
```

内联函数
定义内联函数用 `inline`关键字。
对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。

#### 静态成员static

静态成员在类的所有对象中是共享的

**静态函数成员**
静态成员函数只能访问静态数据成员，不能访问其他静态成员函数和类外部的其他函数。

静态成员函数有一个类范围，他们不能访问类的 this 指针。您可以使用静态成员函数来判断类的某些对象是否已被创建。

### 重载运算符

重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。
**由左操作符调用右操作符**


`A operator符号(A &a)`


```c++
class A
{
   int i;
   int x,y;
   public:
      A(int a=0)
      {
         i=a;
      }
      void show()
      {
         cout<<"i="<<i<<endl;
      }
      A operator+(A &a); //重载运算符+
      {
         A t;
         t.i=i+a.i;
         return t;
      }
      void operator+=(A &a)//重载运算符+=
      {
         i=i+a.i;
      }
      A operator++()//重载前置++,令x+1和y+1
      {
         ++x;
         ++y;
         return *this;
      }
};
A A::operator+(A &a); //重载运算符+，外部实现该函数
      {
         A t;
         t.i=i+a.i;
         return t;
      }
void main()
{
   A a1(10),a2(20),a3,a4;
   a3=a1+a2;   //相当于a3 = a1.operator+ (a2)，由左操作符调用右操作符，因为有返回值，故函数类型为A
   a3.show();  //结果：i=30
   a1+=a2;     //相当于 a1.operator+= (a2)，由左操作符调用右操作符，因为没有返回值，故函数类型为void
   ++a1;//相当于a1.operator++() 
}
```

重载的形参要求：
**没有参数或带有一个参数。**
1. 对于只有一个操作数的运算符（如++），不能有参数；
2. 对于有两个操作数的运算符（如+，-等），只能带一个参数；
3. 参数可以是对象、引用等。

符号优先级：**重载后的符号的优先级不变**。
友元重载函数：对于双目运算符，有两个形参；单目运算符有一个形参。
“=,(),[],->”等不能重载为友元函数。